<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Continuum Nostr Event Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 800px;
      margin: auto;
      padding: 2rem;
      line-height: 1.6;

      /* Continuum watermark background */
      background-color: #f9fafb;
      background-image: url("/images/A_minimalist_digital_image_displays_an_infinity_sy.png");
      background-repeat: repeat;
      background-size: 180px 180px;  /* adjust tile density if needed */
      background-attachment: fixed;

      color: #111;
    }

    .content-container {
      background: #ffffff;
      padding: 2rem;
      margin: 1.5rem auto;
      border-radius: 0.75rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    h1 { margin-bottom: 0.2rem; }

    .meta {
      font-size: 0.9rem;
      color:#555;
      margin-bottom: 0.5rem;
      white-space: pre-line; /* lets the \n show as a second line */
    }

    .summary {
      background:#eef2ff;
      padding:0.75rem 1rem;
      border-radius:0.5rem;
      margin-bottom:1rem;
    }

    .links {
      background:#f3f4f6;
      padding:0.75rem 1rem;
      border-radius:0.5rem;
      margin-bottom:1rem;
      font-size:0.9rem;
    }
    .links a {
      display:inline-block;
      margin-right:1rem;
      margin-bottom:0.3rem;
      color:#2563eb;
      text-decoration:none;
    }
    .links a:hover { text-decoration:underline; }

    pre {
      background:#111;
      color:#eee;
      padding:1rem;
      border-radius:0.5rem;
      font-size:0.85rem;
      overflow-x:auto;

      /* allow wrapping for long encrypted lines */
      white-space: pre-wrap;
      word-break: break-all;
      overflow-wrap: break-word;
            
    }

    /* Special treatment for encrypted blocks so they wrap nicely */
    pre.encblock,
    pre.encblock code {
      font-size: 0.75rem;
      white-space: normal;
      word-break: break-all;
      overflow-wrap: anywhere;
    }

    /* Encrypted blocks that are plain paragraphs (ENCv1:...) */
    p.encblock {
      font-family: "Courier New", Courier, monospace;
      font-size: 0.75rem;
      line-height: 1.2;
      white-space: normal;
      word-break: break-all;
      overflow-wrap: anywhere;
    }    

    #header-image img {
      max-width: 100%;
      border-radius: 0.75rem;
      margin-bottom: 1rem;
      display: block;
    }

    .tags {
      margin: 0.5rem 0 1rem 0;
      font-size: 0.9rem;
      color: #444;
    }
    .tags span {
      background: #eee;
      padding: 3px 8px;
      margin-right: 6px;
      margin-bottom: 6px;
      border-radius: 6px;
      display: inline-block;
    }

    /* show if event is unpublished */
    .unpublished-banner {
      display: none;
      margin: 0.75rem 0 1rem 0;
      padding: 0.6rem 0.75rem;
      border-radius: 0.6rem;
      background: #fef9c3;
      color: #854d0e;
      border: 1px solid #fde68a;
      font-size: 0.9rem;
    }
    .unpublished-banner strong {
      font-weight: 700;
    }

  </style>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
  <div class="content-container">

    <div id="unpublished-banner" class="unpublished-banner">
      <strong>Unpublished</strong> ‚Äî this event is signed and archived locally, but not published to relays.
    </div>
    
    <h1 id="title">Loading‚Ä¶</h1>

    <div class="meta" id="meta"></div>

    <div class="summary" id="summary" style="display:none;"></div>

    <div id="paid-status" style="display:none; font-size:0.9rem; margin:0.5rem 0;"></div>
    
    <div id="tags" style="display:none;" class="tags"></div>

    <div class="links" id="links" style="display:none;"></div>

    <div id="header-image"></div>

    <div id="loading">Fetching event‚Ä¶</div>
    <div id="content"></div>
  </div>

  <script>
    function getEventId() {
      const params = new URLSearchParams(window.location.search);
      return params.get("event_id");
    }
  
    function formatDate(ts) {
      if (!ts) return "";
      return new Date(ts * 1000).toISOString().slice(0, 10);
    }

    // ----- HELPERS for parsing profile content
    function parseProfileContent(content) {
      try {
        const obj = JSON.parse(content || "{}");
        return (obj && typeof obj === "object") ? obj : {};
      } catch {
        return {};
      }
    }

    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    
    // --------- NEW HELPERS FOR PAID DECRYPTION ----------
  
    // base64url ‚Üí Uint8Array
    function base64UrlToBytes(b64url) {
      let b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
      const pad = b64.length % 4;
      if (pad === 2) b64 += '==';
      else if (pad === 3) b64 += '=';
      else if (pad !== 0) throw new Error('Invalid base64url length');
  
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }
  
    // Derive AES key from code + articleId (must match Python: SHA256(code + "|" + article_id))
    async function deriveArticleKey(code, articleId) {
      const enc = new TextEncoder();
      const data = enc.encode(`${code}|${articleId}`);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return crypto.subtle.importKey(
        'raw',
        hash,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
      );
    }
  
    // Optional UI message
    function showPaidStatusMessage(success) {
      const el = document.getElementById('paid-status');
      if (!el) return;
      el.style.display = 'block';
      if (success) {
        el.textContent = 'üîì Paid content unlocked for this article.';
      } else {
        el.textContent = 'üîí Could not decrypt paid article. The unlock code may be missing or invalid.';
      }
    }


    // Try to decrypt paid content if event has enc=aesgcm-v1 and ?code= present
    async function tryDecryptPaidContent(event, content, code) {
      if (!code) {
        return content;
      }
  
      const tags = Array.isArray(event.tags) ? event.tags : [];
  
      // Must be encrypted
      const encTag = tags.find(t => t[0] === 'enc' && t[1] === 'aesgcm-v1');
      if (!encTag) {
        return content;
      }
  
      const dTag = tags.find(t => t[0] === 'd');
      if (!dTag || !dTag[1]) {
        console.warn('No d tag found on paid article');
        return content;
      }
      const articleId = dTag[1];
  
      const startMarker = '<!-- ENC_BLOB_START -->';
      const endMarker = '<!-- ENC_BLOB_END -->';
  
      const startIdx = content.indexOf(startMarker);
      const endIdx = content.indexOf(endMarker);
  
      if (startIdx === -1 || endIdx === -1) {
        console.warn('No ENC_BLOB markers found in paid article content');
        return content;
      }
  
      const blobSection = content.slice(startIdx, endIdx);
      const match = blobSection.match(/ENCv1:([A-Za-z0-9_-]+)/);
      if (!match) {
        console.warn('ENCv1 blob not found between markers');
        return content;
      }
  
      const blobB64url = match[1];
  
      try {
        const blobBytes = base64UrlToBytes(blobB64url);
        if (blobBytes.length < 13) {
          console.warn('Encrypted blob too short');
          return content;
        }
  
        const iv = blobBytes.slice(0, 12);
        const ct = blobBytes.slice(12);
  
        const key = await deriveArticleKey(code, articleId);
  
        const plaintextBuf = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv },
          key,
          ct
        );
        const dec = new TextDecoder();
        const plaintext = dec.decode(plaintextBuf); // full decrypted body
        
        console.log('Paid article decrypted successfully');
        showPaidStatusMessage(true);
        
        // ‚úÖ Replace original content entirely with the decrypted body
        return plaintext;
      } catch (err) {
        console.warn('Failed to decrypt paid article:', err);
        showPaidStatusMessage(false);
        return content; // keep teaser + encrypted blob
      }
    }
 
    // Tag encrypted blocks (ENCv1 / ENCv2) so CSS can apply wrapping
    const ENC_PREFIXES = ["ENCv1:", "ENCv2:"];

    function looksEncrypted(text) {
      const t = (text || "").trim();
      return ENC_PREFIXES.some(prefix => t.startsWith(prefix));
    }

    function tagEncryptedBlocks(container) {
      if (!container) return;
      container.querySelectorAll("p, pre, code").forEach(el => {
        if (looksEncrypted(el.textContent)) {
          el.classList.add("encblock");
        }
      });
    }
   
    // helper to extract year from archive url
   
    function extractArchiveYearFromUrl(url) {
      try {
        const u = new URL(url, window.location.href);
        // expects: https://2026.mycontinuum.xyz/archive/...
        const m = u.hostname.match(/^(\d{4})\.mycontinuum\.xyz$/);
        return m ? m[1] : null;
      } catch {
        return null;
      }
    }

    function buildVerifyUrlFromJsonUrl(jsonUrl, npub) {
      const year = extractArchiveYearFromUrl(jsonUrl);
      if (!year) return null;

      // verifier is hosted inside the same year‚Äôs archive domain
      const base = `https://${year}.mycontinuum.xyz/archive/verify.html`;

      const params = new URLSearchParams();
      params.set("src", jsonUrl);
      if (npub) params.set("npub", npub);

      return `${base}?${params.toString()}`;
    }


    // ----------------------------------------------------
  
    async function loadEvent() {
      const eventId = getEventId();
      if (!eventId) {
        window.location.href = "/404.html";
        return;
      }
  
      const params = new URLSearchParams(window.location.search);
      const code = params.get("code"); // may be null
  
      const titleEl = document.getElementById("title");
      const metaEl = document.getElementById("meta");
      const summaryEl = document.getElementById("summary");
      const linksEl = document.getElementById("links");
      const contentEl = document.getElementById("content");
      const tagsEl = document.getElementById("tags");
      const headerImageEl = document.getElementById("header-image");
      const loadingEl = document.getElementById("loading");
  
      try {
        const indexRes = await fetch("index.json", { cache: "no-cache" });
        const index = await indexRes.json();
        const entry = index.find(e => e.event_id === eventId);
  
        if (!entry) {
          window.location.href = "/404.html";
          return;
        }

        // Show "Unpublished" banner if this entry is explicitly unpublished
        if (entry.published === false) {
          const el = document.getElementById("unpublished-banner");
          if (el) el.style.display = "block";
        }        
  
        // Load event JSON
        const jsonUrl = entry.json_url;

        // get year and verifyurl

        const verifyUrl = buildVerifyUrlFromJsonUrl(jsonUrl, entry.npub || "");
        const verifyLinkHtml = verifyUrl
          ? `<a href="${verifyUrl}" target="_blank">Verify Authorship</a>`
        : "";

        const evRes = await fetch(jsonUrl, { cache: "no-cache" });
        const evJson = await evRes.json();
  
        loadingEl.style.display = "none";
  
        const tags = Array.isArray(evJson.tags) ? evJson.tags : [];
        const findTag = (name) => tags.find(t => t[0] === name);
  
        const displayDateTag = findTag("display_date");
        const imageTag = findTag("image");
        const displayDate = displayDateTag ? displayDateTag[1] : "";
  
        // Extract topic tags (no "#")
        const topicTags = tags
          .filter(t => t[0] === "t")
          .map(t => t[1])
          .filter(Boolean);
  
        // Title
        if (evJson.kind === 0) {
          const profile = parseProfileContent(evJson.content);
          titleEl.textContent = profile.display_name || profile.name || entry.npub || "Profile";
        } else {
          titleEl.textContent = entry.title || entry.slug || "Untitled";
        }
        
        // Created & Published
        const createdDate = entry.created_at ? formatDate(entry.created_at) : "";
        const publishedDate = displayDate || createdDate;
  
        // Meta: line 1 (created/published) + line 2 (npub)
        metaEl.textContent =
          `Created: ${createdDate} ‚Ä¢ Published: ${publishedDate}\n` +
          (entry.npub ? `npub: ${entry.npub}` : "");
  
        // Summary
        if (entry.summary) {
          summaryEl.style.display = "block";
          summaryEl.textContent = entry.summary;
        }
  
        // Tag pills
        if (topicTags.length) {
          tagsEl.style.display = "block";
          tagsEl.innerHTML = topicTags
            .map(tag => `<span>${tag}</span>`)
            .join(" ");
        }
  
        // Links
        const base = jsonUrl.replace(/\.json$/i, "");
        const mdUrl = base + ".md";
        const pdfUrl = base + ".pdf";

        // for handling profile urls
        const isProfile = (evJson.kind === 0);

        // For profiles we always want npub
        const npub = entry.npub;

        // For events we want the event id
        const eid = eventId;

        if (isProfile) {
          linksEl.innerHTML = `
            <a href="${jsonUrl}" target="_blank">Raw JSON</a>
            ${verifyLinkHtml}
            <a href="${mdUrl}" target="_blank">Markdown (if exists)</a>
            <a href="${pdfUrl}" target="_blank">PDF (if exists)</a>
            <a href="https://primal.net/p/${npub}" target="_blank">Primal</a>
            <a href="https://coracle.social/${npub}" target="_blank">Coracle</a>
            <a href="https://phoenix.social/${npub}" target="_blank">Snort</a>
            <a href="https://iris.to/${npub}" target="_blank">Iris</a>
            <a href="https://njump.me/${npub}" target="_blank">njump</a>
          `;
        } else {
          linksEl.innerHTML = `
            <a href="${jsonUrl}" target="_blank">Raw JSON</a>
            ${verifyLinkHtml}
            <a href="${mdUrl}" target="_blank">Markdown (if exists)</a>
            <a href="${pdfUrl}" target="_blank">PDF (if exists)</a>
            <a href="https://primal.net/e/${eid}" target="_blank">Primal</a>
            <a href="https://coracle.social/notes/${eid}" target="_blank">Coracle</a>
            <a href="https://phoenix.social/e/${eid}" target="_blank">Phoenix</a>
            <a href="https://njump.me/${eid}" target="_blank">njump</a>
          `;
        }
                
        linksEl.style.display = "block";
  
        // Header image
        if (imageTag && imageTag[1]) {
          const img = document.createElement("img");
          img.src = imageTag[1];
          img.alt = titleEl.textContent || entry.title || entry.slug || "Header image";
          headerImageEl.innerHTML = "";
          headerImageEl.appendChild(img);
        }

        // ‚úÖ Special rendering for kind:0 profiles
        if (evJson.kind === 0) {
          const profile = parseProfileContent(evJson.content);

          // Meta line stays the same; but you can optionally add nip05/lud16
          const extra = [];
          if (profile.nip05) extra.push(`nip05: ${profile.nip05}`);
          if (profile.lud16) extra.push(`lud16: ${profile.lud16}`);
          if (profile.website) extra.push(`website: ${profile.website}`);
          if (extra.length) metaEl.textContent += "\n" + extra.join(" ‚Ä¢ ");

          // Render banner + avatar + about
          const parts = [];

          if (profile.banner) {
            parts.push(`<div><img src="${profile.banner}" style="max-width:100%; border-radius:0.75rem; margin-bottom:1rem; display:block;" /></div>`);
          }

          if (profile.picture) {
            parts.push(`
              <div style="display:flex; gap:1rem; align-items:flex-start; margin-bottom:1rem;">
                <img src="${profile.picture}" style="width:96px; height:96px; border-radius:999px; object-fit:cover;" />
                <div style="font-size:0.95rem; color:#333;">
                  ${profile.name ? `<div><b>${profile.name}</b></div>` : ""}
                  ${profile.display_name ? `<div>${profile.display_name}</div>` : ""}
                </div>
              </div>
            `);
          }

          if (profile.about) {
            // Use <pre> to preserve newlines like profile "about" typically has
            parts.push(`<pre style="background:#f3f4f6; color:#111; border-radius:0.5rem; padding:1rem; white-space:pre-wrap; word-break:break-word;">${escapeHtml(profile.about)}</pre>`);
          }

          // Render links (optional)
          const linkBits = [];
          if (profile.website) linkBits.push(`<a href="${profile.website}" target="_blank">Website</a>`);
          if (profile.nip05) linkBits.push(`<span>nip05: ${escapeHtml(profile.nip05)}</span>`);
          if (profile.lud16) linkBits.push(`<span>lud16: ${escapeHtml(profile.lud16)}</span>`);
          if (linkBits.length) {
            parts.push(`<div class="links" style="display:block;">${linkBits.join(" ‚Ä¢ ")}</div>`);
          }

          contentEl.innerHTML = parts.join("\n");
          return; // ‚úÖ don‚Äôt run markdown/decrypt logic
        }

  
        // Markdown ‚Üí HTML with optional decryption
        const raw = evJson.content || "";
        let effectiveContent = raw;
  
        // üîê NEW: attempt decryption if ?code=... and enc=aesgcm-v1
        effectiveContent = await tryDecryptPaidContent(evJson, effectiveContent, code);
  
        let html = "";
        try {
          html = marked.parse(effectiveContent);
        } catch {
          html = "";
        }
  
        if (html.trim()) {
          contentEl.innerHTML = html;
          // üîê Tag encrypted blocks so they wrap nicely
          tagEncryptedBlocks(contentEl);
                    
        } else {
          const pre = document.createElement("pre");
          pre.textContent = JSON.stringify(evJson, null, 2);
          contentEl.appendChild(pre);
        }
  
      } catch (err) {
        console.error(err);
        window.location.href = "/404.html";
      }
    }
  
    loadEvent();
  </script>

</body>
</html>
